// Autogenerated from Pigeon (v26.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon
@file:Suppress("UNCHECKED_CAST", "ArrayInDataClass")

package com.xsoulspace.rustore_billing_api

import android.util.Log
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.EventChannel
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMethodCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer
private object RustoreApiPigeonUtils {

  fun createConnectionError(channelName: String): FlutterError {
    return FlutterError("channel-error",  "Unable to establish connection on channel: '$channelName'.", "")  }

  fun wrapResult(result: Any?): List<Any?> {
    return listOf(result)
  }

  fun wrapError(exception: Throwable): List<Any?> {
    return if (exception is FlutterError) {
      listOf(
        exception.code,
        exception.message,
        exception.details
      )
    } else {
      listOf(
        exception.javaClass.simpleName,
        exception.toString(),
        "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(exception)
      )
    }
  }
  fun deepEquals(a: Any?, b: Any?): Boolean {
    if (a is ByteArray && b is ByteArray) {
        return a.contentEquals(b)
    }
    if (a is IntArray && b is IntArray) {
        return a.contentEquals(b)
    }
    if (a is LongArray && b is LongArray) {
        return a.contentEquals(b)
    }
    if (a is DoubleArray && b is DoubleArray) {
        return a.contentEquals(b)
    }
    if (a is Array<*> && b is Array<*>) {
      return a.size == b.size &&
          a.indices.all{ deepEquals(a[it], b[it]) }
    }
    if (a is List<*> && b is List<*>) {
      return a.size == b.size &&
          a.indices.all{ deepEquals(a[it], b[it]) }
    }
    if (a is Map<*, *> && b is Map<*, *>) {
      return a.size == b.size && a.all {
          (b as Map<Any?, Any?>).containsKey(it.key) &&
          deepEquals(it.value, b[it.key])
      }
    }
    return a == b
  }
      
}

/**
 * Error class for passing custom error details to Flutter via a thrown PlatformException.
 * @property code The error code.
 * @property message The error message.
 * @property details The error details. Must be a datatype supported by the api codec.
 */
class FlutterError (
  val code: String,
  override val message: String? = null,
  val details: Any? = null
) : Throwable()

enum class RustoreBillingTheme(val raw: Int) {
  LIGHT(0),
  DARK(1);

  companion object {
    fun ofRaw(raw: Int): RustoreBillingTheme? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class RustorePurchaseAvailabilityType(val raw: Int) {
  AVAILABLE(0),
  UNAVAILABLE(1),
  UNKNOWN(2);

  companion object {
    fun ofRaw(raw: Int): RustorePurchaseAvailabilityType? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class RustorePurchaseState(val raw: Int) {
  CREATED(0),
  INVOICE_CREATED(1),
  CONFIRMED(2),
  PAID(3),
  CANCELLED(4),
  CONSUMED(5),
  CLOSED(6);

  companion object {
    fun ofRaw(raw: Int): RustorePurchaseState? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class RustorePaymentResultType(val raw: Int) {
  SUCCESS(0),
  CANCELLED(1),
  FAILURE(2),
  INVALID_PAYMENT_STATE(3);

  companion object {
    fun ofRaw(raw: Int): RustorePaymentResultType? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class RustoreExceptionType(val raw: Int) {
  NOT_INSTALLED(0),
  OUTDATED(1),
  USER_UNAUTHORIZED(2),
  REQUEST_LIMIT_REACHED(3),
  REVIEW_EXISTS(4),
  INVALID_REVIEW_INFO(5),
  GENERAL(6);

  companion object {
    fun ofRaw(raw: Int): RustoreExceptionType? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class RustoreBillingConfig (
  val consoleApplicationId: String,
  val deeplinkScheme: String,
  val debugLogs: Boolean,
  val theme: RustoreBillingTheme,
  val enableLogging: Boolean
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): RustoreBillingConfig {
      val consoleApplicationId = pigeonVar_list[0] as String
      val deeplinkScheme = pigeonVar_list[1] as String
      val debugLogs = pigeonVar_list[2] as Boolean
      val theme = pigeonVar_list[3] as RustoreBillingTheme
      val enableLogging = pigeonVar_list[4] as Boolean
      return RustoreBillingConfig(consoleApplicationId, deeplinkScheme, debugLogs, theme, enableLogging)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      consoleApplicationId,
      deeplinkScheme,
      debugLogs,
      theme,
      enableLogging,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is RustoreBillingConfig) {
      return false
    }
    if (this === other) {
      return true
    }
    return RustoreApiPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class RustorePurchaseAvailabilityResult (
  val resultType: RustorePurchaseAvailabilityType,
  val cause: RustoreException? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): RustorePurchaseAvailabilityResult {
      val resultType = pigeonVar_list[0] as RustorePurchaseAvailabilityType
      val cause = pigeonVar_list[1] as RustoreException?
      return RustorePurchaseAvailabilityResult(resultType, cause)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      resultType,
      cause,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is RustorePurchaseAvailabilityResult) {
      return false
    }
    if (this === other) {
      return true
    }
    return RustoreApiPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class RustoreProduct (
  val productId: String,
  val productType: String,
  val title: String? = null,
  val description: String? = null,
  val price: Long? = null,
  val priceLabel: String? = null,
  val currency: String? = null,
  val language: String? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): RustoreProduct {
      val productId = pigeonVar_list[0] as String
      val productType = pigeonVar_list[1] as String
      val title = pigeonVar_list[2] as String?
      val description = pigeonVar_list[3] as String?
      val price = pigeonVar_list[4] as Long?
      val priceLabel = pigeonVar_list[5] as String?
      val currency = pigeonVar_list[6] as String?
      val language = pigeonVar_list[7] as String?
      return RustoreProduct(productId, productType, title, description, price, priceLabel, currency, language)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      productId,
      productType,
      title,
      description,
      price,
      priceLabel,
      currency,
      language,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is RustoreProduct) {
      return false
    }
    if (this === other) {
      return true
    }
    return RustoreApiPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class RustorePurchase (
  val purchaseId: String? = null,
  val productId: String? = null,
  val invoiceId: String? = null,
  val description: String? = null,
  val language: String? = null,
  val purchaseTime: String? = null,
  val orderId: String? = null,
  val amountLabel: String? = null,
  val amount: Long? = null,
  val currency: String? = null,
  val quantity: Long? = null,
  val purchaseState: RustorePurchaseState? = null,
  val developerPayload: String? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): RustorePurchase {
      val purchaseId = pigeonVar_list[0] as String?
      val productId = pigeonVar_list[1] as String?
      val invoiceId = pigeonVar_list[2] as String?
      val description = pigeonVar_list[3] as String?
      val language = pigeonVar_list[4] as String?
      val purchaseTime = pigeonVar_list[5] as String?
      val orderId = pigeonVar_list[6] as String?
      val amountLabel = pigeonVar_list[7] as String?
      val amount = pigeonVar_list[8] as Long?
      val currency = pigeonVar_list[9] as String?
      val quantity = pigeonVar_list[10] as Long?
      val purchaseState = pigeonVar_list[11] as RustorePurchaseState?
      val developerPayload = pigeonVar_list[12] as String?
      return RustorePurchase(purchaseId, productId, invoiceId, description, language, purchaseTime, orderId, amountLabel, amount, currency, quantity, purchaseState, developerPayload)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      purchaseId,
      productId,
      invoiceId,
      description,
      language,
      purchaseTime,
      orderId,
      amountLabel,
      amount,
      currency,
      quantity,
      purchaseState,
      developerPayload,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is RustorePurchase) {
      return false
    }
    if (this === other) {
      return true
    }
    return RustoreApiPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class RustorePaymentResult (
  val resultType: RustorePaymentResultType,
  val purchaseId: String? = null,
  val errorCode: String? = null,
  val errorMessage: String? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): RustorePaymentResult {
      val resultType = pigeonVar_list[0] as RustorePaymentResultType
      val purchaseId = pigeonVar_list[1] as String?
      val errorCode = pigeonVar_list[2] as String?
      val errorMessage = pigeonVar_list[3] as String?
      return RustorePaymentResult(resultType, purchaseId, errorCode, errorMessage)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      resultType,
      purchaseId,
      errorCode,
      errorMessage,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is RustorePaymentResult) {
      return false
    }
    if (this === other) {
      return true
    }
    return RustoreApiPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class RustoreError (
  val code: String,
  val message: String,
  val description: String? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): RustoreError {
      val code = pigeonVar_list[0] as String
      val message = pigeonVar_list[1] as String
      val description = pigeonVar_list[2] as String?
      return RustoreError(code, message, description)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      code,
      message,
      description,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is RustoreError) {
      return false
    }
    if (this === other) {
      return true
    }
    return RustoreApiPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class RustoreException (
  val type: RustoreExceptionType,
  val message: String,
  val errorCode: String? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): RustoreException {
      val type = pigeonVar_list[0] as RustoreExceptionType
      val message = pigeonVar_list[1] as String
      val errorCode = pigeonVar_list[2] as String?
      return RustoreException(type, message, errorCode)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      type,
      message,
      errorCode,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is RustoreException) {
      return false
    }
    if (this === other) {
      return true
    }
    return RustoreApiPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}
private open class RustoreApiPigeonCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      129.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          RustoreBillingTheme.ofRaw(it.toInt())
        }
      }
      130.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          RustorePurchaseAvailabilityType.ofRaw(it.toInt())
        }
      }
      131.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          RustorePurchaseState.ofRaw(it.toInt())
        }
      }
      132.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          RustorePaymentResultType.ofRaw(it.toInt())
        }
      }
      133.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          RustoreExceptionType.ofRaw(it.toInt())
        }
      }
      134.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          RustoreBillingConfig.fromList(it)
        }
      }
      135.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          RustorePurchaseAvailabilityResult.fromList(it)
        }
      }
      136.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          RustoreProduct.fromList(it)
        }
      }
      137.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          RustorePurchase.fromList(it)
        }
      }
      138.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          RustorePaymentResult.fromList(it)
        }
      }
      139.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          RustoreError.fromList(it)
        }
      }
      140.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          RustoreException.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?)   {
    when (value) {
      is RustoreBillingTheme -> {
        stream.write(129)
        writeValue(stream, value.raw)
      }
      is RustorePurchaseAvailabilityType -> {
        stream.write(130)
        writeValue(stream, value.raw)
      }
      is RustorePurchaseState -> {
        stream.write(131)
        writeValue(stream, value.raw)
      }
      is RustorePaymentResultType -> {
        stream.write(132)
        writeValue(stream, value.raw)
      }
      is RustoreExceptionType -> {
        stream.write(133)
        writeValue(stream, value.raw)
      }
      is RustoreBillingConfig -> {
        stream.write(134)
        writeValue(stream, value.toList())
      }
      is RustorePurchaseAvailabilityResult -> {
        stream.write(135)
        writeValue(stream, value.toList())
      }
      is RustoreProduct -> {
        stream.write(136)
        writeValue(stream, value.toList())
      }
      is RustorePurchase -> {
        stream.write(137)
        writeValue(stream, value.toList())
      }
      is RustorePaymentResult -> {
        stream.write(138)
        writeValue(stream, value.toList())
      }
      is RustoreError -> {
        stream.write(139)
        writeValue(stream, value.toList())
      }
      is RustoreException -> {
        stream.write(140)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}


/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface RustoreBillingApi {
  /** Initialize the RuStore billing client */
  fun initialize(config: RustoreBillingConfig, callback: (Result<Unit>) -> Unit)
  /** Handle deep link intent (for payment flows) */
  fun onNewIntent(intentData: String?)
  /** Check if purchases are available on this device */
  fun checkPurchasesAvailability(callback: (Result<RustorePurchaseAvailabilityResult>) -> Unit)
  /** Check if RuStore is installed on the device */
  fun isRuStoreInstalled(callback: (Result<Boolean>) -> Unit)
  /** Get available products by IDs */
  fun getProducts(productIds: List<String>, callback: (Result<List<RustoreProduct>>) -> Unit)
  /** Get existing purchases */
  fun getPurchases(callback: (Result<List<RustorePurchase>>) -> Unit)
  /** Start purchase flow for a product */
  fun purchaseProduct(productId: String, developerPayload: String?, callback: (Result<RustorePaymentResult>) -> Unit)
  /** Confirm a successful purchase */
  fun confirmPurchase(purchaseId: String, developerPayload: String?, callback: (Result<Unit>) -> Unit)
  /** Delete a purchase */
  fun deletePurchase(purchaseId: String, callback: (Result<Unit>) -> Unit)
  /** Set the billing client theme */
  fun setTheme(theme: RustoreBillingTheme, callback: (Result<Unit>) -> Unit)

  companion object {
    /** The codec used by RustoreBillingApi. */
    val codec: MessageCodec<Any?> by lazy {
      RustoreApiPigeonCodec()
    }
    /** Sets up an instance of `RustoreBillingApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: RustoreBillingApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.rustore_billing_api.RustoreBillingApi.initialize$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val configArg = args[0] as RustoreBillingConfig
            api.initialize(configArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(RustoreApiPigeonUtils.wrapError(error))
              } else {
                reply.reply(RustoreApiPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.rustore_billing_api.RustoreBillingApi.onNewIntent$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val intentDataArg = args[0] as String?
            val wrapped: List<Any?> = try {
              api.onNewIntent(intentDataArg)
              listOf(null)
            } catch (exception: Throwable) {
              RustoreApiPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.rustore_billing_api.RustoreBillingApi.checkPurchasesAvailability$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.checkPurchasesAvailability{ result: Result<RustorePurchaseAvailabilityResult> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(RustoreApiPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(RustoreApiPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.rustore_billing_api.RustoreBillingApi.isRuStoreInstalled$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.isRuStoreInstalled{ result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(RustoreApiPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(RustoreApiPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.rustore_billing_api.RustoreBillingApi.getProducts$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val productIdsArg = args[0] as List<String>
            api.getProducts(productIdsArg) { result: Result<List<RustoreProduct>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(RustoreApiPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(RustoreApiPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.rustore_billing_api.RustoreBillingApi.getPurchases$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.getPurchases{ result: Result<List<RustorePurchase>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(RustoreApiPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(RustoreApiPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.rustore_billing_api.RustoreBillingApi.purchaseProduct$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val productIdArg = args[0] as String
            val developerPayloadArg = args[1] as String?
            api.purchaseProduct(productIdArg, developerPayloadArg) { result: Result<RustorePaymentResult> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(RustoreApiPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(RustoreApiPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.rustore_billing_api.RustoreBillingApi.confirmPurchase$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val purchaseIdArg = args[0] as String
            val developerPayloadArg = args[1] as String?
            api.confirmPurchase(purchaseIdArg, developerPayloadArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(RustoreApiPigeonUtils.wrapError(error))
              } else {
                reply.reply(RustoreApiPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.rustore_billing_api.RustoreBillingApi.deletePurchase$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val purchaseIdArg = args[0] as String
            api.deletePurchase(purchaseIdArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(RustoreApiPigeonUtils.wrapError(error))
              } else {
                reply.reply(RustoreApiPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.rustore_billing_api.RustoreBillingApi.setTheme$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val themeArg = args[0] as RustoreBillingTheme
            api.setTheme(themeArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(RustoreApiPigeonUtils.wrapError(error))
              } else {
                reply.reply(RustoreApiPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
class RustoreBillingCallbackApi(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by RustoreBillingCallbackApi. */
    val codec: MessageCodec<Any?> by lazy {
      RustoreApiPigeonCodec()
    }
  }
  /** Called when purchase state changes */
  fun onPurchaseResult(resultArg: RustorePaymentResult, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.rustore_billing_api.RustoreBillingCallbackApi.onPurchaseResult$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(resultArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(RustoreApiPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
  /** Called when an error occurs */
  fun onError(errorArg: RustoreError, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.rustore_billing_api.RustoreBillingCallbackApi.onError$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(errorArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(RustoreApiPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
}
